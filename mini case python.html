<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Miniproject: SDH Subtitle Automation</title>
    <style>
        :root {
            --primary: #003366;
            --primary-light: #e8f0f0;
            --accent: #2c5282;
            --success: #2f855a;
            --border: #cbd5e0;
            --border-light: #e2e8f0;
            --card: #ffffff;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Calibri', 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #fff;
            max-width: 210mm;
            margin: 0 auto;
            padding: 15mm;
            font-size: 10.5pt;
        }
        
        /* HEADER */
        .project-header {
            text-align: center;
            border-bottom: 4px solid #003366;
            padding-bottom: 20pt;
            margin-bottom: 25pt;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20pt;
            border-radius: 8px;
        }
        
        .project-number {
            font-size: 14pt;
            font-weight: bold;
            color: #003366;
            margin-bottom: 8pt;
            text-transform: uppercase;
            letter-spacing: 1.5pt;
        }
        
        .project-header h1 {
            font-size: 18pt;
            color: #003366;
            margin-bottom: 2pt;
            text-transform: none;
            letter-spacing: normal;
            border-bottom: none;
            padding-bottom: 0;
        }
        
        .project-subtitle {
            font-size: 12pt;
            color: #003366;
            font-weight: 600;
            margin-bottom: 15pt;
            font-style: italic;
        }
        
        .project-tags {
            margin-top: 15pt;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 6pt;
        }
        
        .project-tag {
            display: inline-block;
            background: #003366;
            color: white;
            padding: 4pt 10pt;
            border-radius: 5px;
            font-size: 9.5pt;
            font-weight: bold;
            margin-right: 0;
            margin-bottom: 8pt;
        }
        
        /* CONTEXT BOX */
        .context-box {
            background: #f9f9f9;
            padding: 15pt;
            border-left: 4px solid #003366;
            margin-bottom: 20pt;
            border-radius: 0 4px 4px 0;
        }
        
        /* SECTIONS */
        section {
            margin-bottom: 30pt;
            page-break-inside: avoid;
        }
        
        h2 {
            font-size: 14pt;
            font-weight: bold;
            color: #003366;
            border-bottom: 3px solid #003366;
            padding-bottom: 5pt;
            margin-bottom: 15pt;
            text-transform: uppercase;
            letter-spacing: 0.8pt;
        }
        
        h3 {
            font-size: 12pt;
            font-weight: bold;
            color: #003366;
            margin-top: 18pt;
            margin-bottom: 10pt;
            border-left: 5px solid #003366;
            padding-left: 10pt;
        }
        
        /* TWO COLUMNS */
        .two-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20pt;
            margin: 20pt 0;
        }
        
        .problem-box, .solution-box {
            background: white;
            border: 2px solid #003366;
            border-radius: 8px;
            padding: 15pt;    
            box-shadow: 0 4px 12px rgba(0, 51, 102, 0.1);
        }
        
        .problem-box h3, .solution-box h3 {
            text-align: center;
            margin-top: 3pt;
            border: none;
            padding-left: 0;
            color: #003366;
            margin-bottom: 12pt;
            padding-bottom: 8pt;
            border-bottom: 1px solid #003366;
        }
        
        /* CODE BLOCK */
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20pt;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 10pt;
            line-height: 1.4;
            margin: 20pt 0;
            overflow-x: auto;
        }
        
        .code-comment {
            color: #a0aec0;
        }
        
        .code-keyword {
            color: #63b3ed;
        }
        
        .code-string {
            color: #68d391;
        }
        
        .code-function {
            color: #fbb6ce;
        }
        
        /* BEFORE/AFTER VISUAL */
        .before-after {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15pt;
            margin: 20pt 0;
        }
        
        .before-box, .after-box {
            background: white;
            border-radius: 8px;
            padding: 15pt;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .before-box {
            border: 2px solid #c53030;
        }
        
        .after-box {
            border: 2px solid #2f855a;
        }
        
        .before-box h4, .after-box h4 {
            font-size: 11pt;
            text-align: center;
            margin-bottom: 10pt;
            padding-bottom: 5pt;
            border-bottom: 1px solid;
        }
        
        .before-box h4 {
            color: #c53030;
            border-bottom-color: #c53030;
        }
        
        .after-box h4 {
            color: #2f855a;
            border-bottom-color: #2f855a;
        }
        
        /* RESULTS */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15pt;
            margin: 20pt 0;
        }
        
        .result-card {
            background: #f0f7ff;
            border: 1px solid #003366;
            border-radius: 6px;
            padding: 15pt;
            text-align: center;
        }
        
        .result-value {
            font-size: 16pt;
            font-weight: bold;
            color: #003366;
            margin-bottom: 6pt;
        }
        
        .result-label {
            font-size: 10pt;
            color: #666;
        }
        
        /* LISTS */
        ul {
            margin-left: 20pt;
            margin-top: 8pt;
        }
        
        li {
            margin-bottom: 8pt;
            text-align: justify;
        }
        
        strong {
            color: #003366;
        }
        
        pre {
            background: #f5f5f5;
            padding: 10pt;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 9.5pt;
            margin: 10pt 0;
        }
        
        @media print {
            body { padding: 5mm; }
        }
    </style>
</head>
<body>

    <!-- PROJECT HEADER -->
    <div class="project-header">
        <div class="project-number">PYTHON MINIPROJECT — EMLDS PORTFOLIO</div>
        <h1>Automated Metadata Structuring<br> for Video Subtitles</h1>
        <div class="project-subtitle">A practical application of Python scripting for optimizing linguistic workflows</div>
        <div class="project-tags">
            <span class="project-tag">Python Scripting</span>
            <span class="project-tag">Text Processing</span>
            <span class="project-tag">Workflow Automation</span>
            <span class="project-tag">Data Structuring</span>
            <span class="project-tag">Applied Linguistics</span>
        </div>
    </div>

    <!-- CONTEXT -->
    <div class="context-box">
        <strong>Real-world context:</strong> During subtitle work for Amazon Prime Video, I faced the challenge of manually adding complex SDH (Subtitles for the Deaf and Hard of Hearing) metadata structures to raw subtitle files. Each line required repetitive typing of markers, separators, and mandatory fields—a slow and error-prone process.
    </div>

    <!-- THE PROBLEM vs THE SOLUTION -->
    <div class="two-columns">
        <div class="problem-box">
            <h3>The Manual Problem</h3>
            <ul>
                <li>80% of time spent on repetitive formatting</li>
                <li>Manual typing of fixed structures for each line</li>
                <li>Risk of inconsistency in separators and markers</li>
                <li>Average time: 8-10 seconds per subtitle line</li>
                <li>Frequent formatting errors requiring revision</li>
            </ul>
        </div>
        
        <div class="solution-box">
            <h3>The Automated Solution</h3>
            <ul>
                <li>Python script for file reading and transformation</li>
                <li>Automatic identification of timestamps and dialogues</li>
                <li>Automatic insertion of complete metadata structure</li>
                <li>Time reduced to 2-3 seconds per line</li>
                <li>100% consistent formatting standardization</li>
            </ul>
        </div>
    </div>

    <!-- THE PYTHON CODE -->
    <section>
        <h2>THE CODE: AUTOMATIC FORMATTING FUNCTION</h2>
        
        <div class="code-block">
<span class="code-keyword">def</span> <span class="code-function">format_subtitle_template</span>(input_file, output_file):<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">"""</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">Reads a raw subtitle file and generates a formatted template</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">with metadata structure ready for completion.</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment">"""</span><br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">with</span> <span class="code-function">open</span>(input_file, <span class="code-string">'r'</span>, encoding=<span class="code-string">'utf-8'</span>) <span class="code-keyword">as</span> f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lines = f.<span class="code-function">readlines</span>()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;formatted_lines = []<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">for</span> line <span class="code-keyword">in</span> lines:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"># Detects timestamp lines</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">if</span> <span class="code-string">'-->'</span> <span class="code-keyword">in</span> line:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timestamp = line.<span class="code-function">strip</span>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"># Gets the next line (dialogue)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next_line_index = lines.<span class="code-function">index</span>(line) + 1<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">if</span> next_line_index < <span class="code-function">len</span>(lines):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dialogue = lines[next_line_index].<span class="code-function">strip</span>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"># Creates template with empty fields</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatted = <span class="code-function">f</span><span class="code-string">"{timestamp} {{S: || A: || L: || T: }} [sub: || action: || cap: || P] {dialogue}\n"</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatted_lines.<span class="code-function">append</span>(formatted)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">else</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatted_lines.<span class="code-function">append</span>(line)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">else</span>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-comment"># Keeps scene numbers and empty lines</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;formatted_lines.<span class="code-function">append</span>(line)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="code-keyword">with</span> <span class="code-function">open</span>(output_file, <span class="code-string">'w'</span>, encoding=<span class="code-string">'utf-8'</span>) <span class="code-keyword">as</span> f:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.<span class="code-function">writelines</span>(formatted_lines)<br>
<br>
<span class="code-comment"># Function usage</span><br>
<span class="code-function">format_subtitle_template</span>(<span class="code-string">"raw_subtitle.srt"</span>, <span class="code-string">"formatted_subtitle.txt"</span>)
        </div>
        
        <h3>Line-by-Line Explanation</h3>
        <ol>
            <li><strong>Lines 1-5:</strong> Defines the function and its documentation (docstring)</li>
            <li><strong>Lines 7-8:</strong> Opens the input file with UTF-8 encoding</li>
            <li><strong>Line 11:</strong> Creates empty list to store formatted lines</li>
            <li><strong>Lines 13-14:</strong> Iterates through each line of the original file</li>
            <li><strong>Line 16:</strong> Checks if the line contains a timestamp (-->)</li>
            <li><strong>Lines 18-23:</strong> Processes timestamps and their corresponding dialogues</li>
            <li><strong>Lines 25-30:</strong> Adds metadata structure with empty fields</li>
            <li><strong>Lines 33-35:</strong> Saves all formatted lines to the new file</li>
        </ol>
    </section>

    <!-- BEFORE AND AFTER -->
    <section>
        <h2>VISUAL TRANSFORMATION: BEFORE AND AFTER</h2>
        
        <div class="before-after">
            <div class="before-box">
                <h4>BEFORE: Raw Subtitle (SRT)</h4>
                <pre>
11
00:00:30,823 --> 00:00:32,408
Foram pra festa? Foi boa?

12
00:00:35,100 --> 00:00:37,500
Sim, foi incrível!
                </pre>
                <p><strong>Manual time:</strong> 8-10 seconds per line<br>
                <strong>Error risk:</strong> High (inconsistent formatting)</p>
            </div>
            
            <div class="after-box">
                <h4>AFTER: Formatted Template</h4>
                <pre>
11
00:00:30,823 --> 00:00:32,408 {S: || A: || L: || T: } [sub: || action: || cap: || P] Foram pra festa? Foi boa?

12
00:00:35,100 --> 00:00:37,500 {S: || A: || L: || T: } [sub: || action: || cap: || P] Sim, foi incrível!
                </pre>
                <p><strong>Automated time:</strong> 2-3 seconds per line<br>
                <strong>Consistency:</strong> 100% (automatic standardization)</p>
            </div>
        </div>
    </section>

    <!-- RESULTS AND IMPACT -->
    <section>
        <h2>RESULTS AND OPERATIONAL IMPACT</h2>
        
        <div class="results-grid">
            <div class="result-card">
                <div class="result-value">-70%</div>
                <div class="result-label">Reduction in formatting time</div>
            </div>
            
            <div class="result-card">
                <div class="result-value">100%</div>
                <div class="result-label">Consistency in metadata structure</div>
            </div>
            
            <div class="result-card">
                <div class="result-value">0 errors</div>
                <div class="result-label">In formatting after implementation</div>
            </div>
            
            <div class="result-card">
                <div class="result-value">+6 hours</div>
                <div class="result-label">Saved per 1000-subtitle project</div>
            </div>
        </div>
        
        <h3>Additional Benefits</h3>
        <ul>
            <li><strong>Focus on data quality:</strong> Time freed for research on character names, actors, and tone analysis</li>
            <li><strong>Scalability:</strong> Processing of hundreds of files with a single command</li>
            <li><strong>Reproducibility:</strong> Same result regardless of operator</li>
            <li><strong>Foundation for future automation:</strong> Structure ready for integration with APIs or batch processing</li>
        </ul>
    </section>

    <!-- CONNECTION WITH EMLDS -->
    <section>
        <h2>CONNECTION WITH THE EMLDS PROGRAM</h2>
        
        <div class="context-box">
            <p>This miniproject serves as a foundation for the advanced topics covered in the EMLDS program, demonstrating the progression from basic scripting to sophisticated linguistic data processing. The current solution addresses workflow optimization, while the envisioned extensions align with core program competencies.</p>
        </div>
        
        <h3>Demonstrated Foundational Skills</h3>
        <ul>
            <li><strong>Text Processing Fundamentals:</strong> String manipulation, regular expressions, and parsing of domain-specific formats (SRT)</li>
            <li><strong>Workflow Analysis & Automation:</strong> Systematic identification of repetitive tasks and creation of scalable solutions</li>
            <li><strong>Data Structuring & Normalization:</strong> Transformation of unstructured textual data into consistent, field-based templates</li>
            <li><strong>Algorithmic Problem-Solving:</strong> Application of computational thinking to real-world linguistic workflows</li>
        </ul>
        
        <h3>Advanced Applications for EMLDS Development</h3>
        <ul>
            <li><strong>Sentiment & Tone Analysis Integration:</strong> Using libraries like TextBlob, VADER, or spaCy to automatically detect and tag emotional tones (sarcastic, playful, angry) in dialogue, reducing manual annotation time by 60-80%</li>
            <li><strong>Named Entity Recognition (NER) for Character Identification:</strong> Implementing spaCy or Stanza NER models to automatically identify character names and speakers in dialogue, creating initial speaker metadata templates</li>
            <li><strong>Speech-Act Classification:</strong> Training models to classify dialogue lines into speech acts (question, command, statement, exclamation) to automatically generate appropriate action descriptions</li>
            <li><strong>Multilingual Metadata Alignment:</strong> Developing cross-lingual pipelines that maintain metadata consistency across translated subtitle versions using alignment algorithms</li>
            <li><strong>Acoustic Event Detection Integration:</strong> Combining subtitle text with audio analysis to automatically generate descriptive captions for non-speech sounds [door slams], [laughter], [music]</li>
            <li><strong>Dialogue Act Segmentation:</strong> Using transformer models to identify natural pause points and segment long dialogues according to linguistic rather than arbitrary temporal boundaries</li>
            <li><strong>Bias Detection in Character Representation:</strong> Analyzing gender, ethnicity, and social role patterns in how characters are described in SDH metadata to identify and mitigate representational biases</li>
            <li><strong>Cross-Modal Validation:</strong> Creating validation systems that compare subtitle timing with actual speech rate and pause patterns to flag potential alignment errors</li>
        </ul>

        <h3>Research Questions Emerging from This Work</h3>
        <ul>
            <li>How can sentiment analysis models be adapted to accurately capture dramatic/cinematic tone (vs. general text sentiment)?</li>
            <li>What are the optimal feature sets for automatically distinguishing between main characters and background speakers in dialogue?</li>
            <li>How can multilingual NER systems maintain character identity consistency across dubbed and subtitled versions?</li>
            <li>What ethical frameworks are needed for automated generation of accessibility metadata to ensure respectful and accurate representation?</li>
        </ul>
    </section>

</body>
</html>